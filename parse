Libft/ft_lst/ft_lstmap.c:	new->next = ft_lstmap(lst->next, f);
Libft/ft_lst/ft_lstnew.c:	list->content = new_content;
Libft/ft_lst/ft_lstnew.c:	list->content_size = content_size;
Libft/ft_lst/ft_lstnew.c:	list->next = NULL;
Libft/ft_lst/ft_lstnew_cuda.c:	list->content = new_content;
Libft/ft_lst/ft_lstnew_cuda.c:	list->content_size = content_size;
Libft/ft_lst/ft_lstnew_cuda.c:	list->next = NULL;
Libft/ft_misc/ft_range.c:			array[i++] = start--;
Libft/ft_printf/check_flags.c:			result[i + comma_count--] = ',';
Libft/ft_str/ft_strsplit.c:		word_count--;
src/data_prep/check_scene.c:	if (!v_isnan(light->look_at) && !v_isnan(light->pos))
src/data_prep/check_scene.c:		light->dir = v_sub(light->look_at, light->pos);
src/data_prep/check_scene.c:	if (v_isnan(light->dir) ||
src/data_prep/check_scene.c:		(!light->dir.x && !light->dir.y && !light->dir.z))
src/data_prep/check_scene.c:		set_default_light_dir(scene, T_LIGHT, light, &light->dir);
src/data_prep/check_scene.c:	light->dir = v_norm(light->dir);
src/gui/sig_errors.c:	if (g->t->input)
src/gui/sig_errors.c:		line_number = ft_itoa((int)g->t->input->line_number);
src/gui/sig_new_light.c:	// light->type = T_SPHERICAL;
src/gui/sig_new_light.c:    light->intensity = DEFAULT_INTENSITY;
src/gui/sig_new_light.c:	light->col = v_new(DEFAULT_COL_R, DEFAULT_COL_G, DEFAULT_COL_B);
src/gui/sig_new_light.c:	light->name = ft_strdup("New light");
src/gui/sig_new_light.c:	light->next = NULL;
src/gui/sig_open_scene.c:	if ((ret = parse_input(g->t)) || (ret = check_scene(g->t->scene)))
src/gui/sig_open_scene.c:	g->r->scene = g->t->scene;
src/gui/sig_save.c:	write(fd, light->name, ft_strlen(light->name));
src/gui/sig_save.c:	write_vector(fd, light->pos);
src/gui/sig_save.c:	if (!v_isnan(light->dir))
src/gui/sig_save.c:		write_vector(fd, light->dir);
src/gui/sig_save.c:	write_vector(fd, (t_vec3)light->col);
src/gui/sig_save.c:	write_int(fd, light->intensity);
src/gui/sig_update_cameras.c:		if (!v_isnan(light->pos))
src/gui/sig_update_cameras.c:			gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT(widget), (const gchar *)light->name);
src/gui/sig_update_cameras.c:		light = light->next;
src/gui/sig_update_lights.c:		label = gtk_label_new(light->name);
src/gui/sig_update_lights.c:		light = light->next;
src/gui/sig_update_lights.c:	// if (!g->updating_gui && v_isnan(light->dir))
src/gui/sig_update_lights.c:	gtk_entry_set_text (GTK_ENTRY(widget), light->name);
src/gui/sig_update_lights.c:	gtk_spin_button_set_value(GTK_SPIN_BUTTON(widget), light->pos.x);
src/gui/sig_update_lights.c:	gtk_spin_button_set_value(GTK_SPIN_BUTTON(widget), light->pos.y);
src/gui/sig_update_lights.c:	gtk_spin_button_set_value(GTK_SPIN_BUTTON(widget), light->pos.z);
src/gui/sig_update_lights.c:	gtk_spin_button_set_value(GTK_SPIN_BUTTON(widget), light->dir.x);
src/gui/sig_update_lights.c:	gtk_spin_button_set_value(GTK_SPIN_BUTTON(widget), light->dir.y);
src/gui/sig_update_lights.c:	gtk_spin_button_set_value(GTK_SPIN_BUTTON(widget), light->dir.z);
src/gui/sig_update_lights.c:	gtk_spin_button_set_value(GTK_SPIN_BUTTON(widget), light->intensity);
src/gui/sig_update_lights.c:	color.red = light->col.x / 255.0;
src/gui/sig_update_lights.c:	color.green = light->col.y / 255.0;
src/gui/sig_update_lights.c:	color.blue = light->col.z / 255.0;
src/gui/sig_update_lights.c:		light = light->next;
src/gui/sig_update_lights.c:		light->dir = v_new(NAN, NAN, NAN);
src/gui/sig_update_lights.c:		if (v_isnan(light->pos))
src/gui/sig_update_lights.c:			light->pos = v_new(DEFAULT_POS_X, DEFAULT_POS_Y, DEFAULT_POS_Z);
src/gui/sig_update_lights.c:			light->pos = v_new(light->pos.x, light->pos.y, light->pos.z);
src/gui/sig_update_lights.c:		light->pos = v_new(NAN, NAN, NAN);
src/gui/sig_update_lights.c:		if (v_isnan(light->dir))
src/gui/sig_update_lights.c:			light->dir = v_new(DEFAULT_DIR_X, -DEFAULT_DIR_Y, DEFAULT_DIR_Z);
src/gui/sig_update_lights.c:			light->dir = v_new(light->dir.x, light->dir.y, light->dir.z);
src/gui/sig_update_lights.c:	free(light->name);
src/gui/sig_update_lights.c:	light->name = name;
src/gui/sig_update_objects.c:		if (!v_isnan(light->pos))
src/gui/sig_update_objects.c:			gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT(widget), (const gchar *)light->name);
src/gui/sig_update_objects.c:		light = light->next;
src/gui/sig_update_objects.c:		light = light->next;
src/gui/sig_update_objects.c:		return (light->pos);
src/list/get_new_camera.c:	if (!t->input->value || !*t->input->value)
src/list/get_new_camera.c:		new_camera->name = ft_strjoin(t->tokens[t->input->token], " ");
src/list/get_new_camera.c:		new_camera->name = ft_strdup(t->input->value);
src/list/get_new_input.c:	new_input->value = NULL;
src/list/get_new_input.c:	new_input->next = NULL;
src/list/get_new_input.c:	new_input->token = ft_charcount(line, ':') < 2 ?
src/list/get_new_input.c:		new_input->value = ft_strdup(key_value[1]);
src/list/get_new_input.c:	new_input->file_name = ft_strdup(file_name);
src/list/get_new_light.c:	if (!t->input->value || !*t->input->value)
src/list/get_new_light.c:		new_light->name = ft_strjoin(t->tokens[t->input->token], " ");
src/list/get_new_light.c:		new_light->name = ft_strjoinfree(new_light->name, ft_itoa(i), 'b');
src/list/get_new_light.c:		new_light->name = ft_strdup(t->input->value);
src/list/get_new_light.c:	new_light->next = NULL;
src/list/get_new_light.c:	new_light->pos = v_new(NAN, NAN, NAN);
src/list/get_new_light.c:	new_light->dir = v_new(NAN, NAN, NAN);
src/list/get_new_light.c:	new_light->look_at = v_new(NAN, NAN, NAN);
src/list/get_new_light.c:	new_light->col = v_new(NAN, NAN, NAN);
src/list/get_new_light.c:	new_light->intensity = NAN;
src/list/get_new_light.c:	new_light->name = NULL;
src/list/get_new_object.c:	if (!t->input->value || !*t->input->value)
src/list/get_new_object.c:		new_object->name = ft_strjoin(t->tokens[t->input->token], " ");
src/list/get_new_object.c:		new_object->name = ft_strjoinfree(new_object->name, ft_itoa(i), 'b');
src/list/get_new_object.c:		new_object->name = ft_strdup(t->input->value);
src/list/get_new_object.c:	new_object->type = t->input->token;
src/list/get_new_object.c:	new_object->name = NULL;
src/list/get_new_object.c:	new_object->next = NULL;
src/list/get_new_object.c:	new_object->obj = NULL;
src/list/get_new_object.c:	new_object->pos = v_new(NAN, NAN, NAN);
src/list/get_new_object.c:	new_object->dir = v_new(NAN, NAN, NAN);
src/list/get_new_object.c:	new_object->look_at = v_new(NAN, NAN, NAN);
src/list/get_new_object.c:	new_object->col = v_new(NAN, NAN, NAN);
src/list/get_new_object.c:	new_object->texture = NULL;
src/list/get_new_object.c:	new_object->texture_ratio.x = 1; // TODO
src/list/get_new_object.c:	new_object->texture_ratio.y = 1; // TODO
src/list/get_new_object.c:	new_object->texture_translate.x = 0; // TODO
src/list/get_new_object.c:	new_object->texture_translate.y = 0; // TODO
src/list/get_new_object.c:	new_object->rad = NAN;
src/list/get_new_object.c:	new_object->height = NAN;
src/list/get_new_object.c:	new_object->ior = NAN;
src/list/get_new_object.c:	new_object->reflection = NAN;
src/list/get_new_object.c:	new_object->specular_exp = NAN;
src/list/get_new_object.c:	new_object->ks = NAN;
src/list/get_new_object.c:	new_object->kd = NAN;
src/list/get_new_object.c:	new_object->transparency = NAN;
src/list/get_new_scene.c:	new_scene->name = (!t->input->value || !*t->input->value) ?
src/list/get_new_scene.c:		ft_strdup(t->input->value);
src/list/push_light.c:		new_light->next = NULL;
src/list/push_object.c:		new_object->next = NULL;
src/list/remove_camera.c:				head->next->prev = NULL;
src/list/remove_camera.c:				head->next->prev = head->prev;
src/misc/free_parse_tools.c:	free_input(t->input_head);
src/misc/free_parse_tools.c:	free_colors(t->colors);
src/misc/free_parse_tools.c:	free_tokens(t->tokens);
src/misc/free_parse_tools.c:	free(t->tokens);
src/misc/free_parse_tools.c:	t->tokens = NULL;
src/misc/free_parse_tools.c:	free(t->global_attributes);
src/misc/free_parse_tools.c:	free(t->scene_attributes);
src/misc/free_parse_tools.c:	free(t->object_attributes);
src/misc/free_parse_tools.c:	free(t->parse);
src/misc/free_parse_tools.c:		free(input->value);
src/misc/free_parse_tools.c:		input->value = NULL;
src/misc/free_parse_tools.c:		if (input->file_name)
src/misc/free_parse_tools.c:			free(input->file_name);
src/misc/free_parse_tools.c:		input->file_name = NULL;
src/misc/free_parse_tools.c:		input = input->next;
src/misc/free_parse_tools.c:		if (list->name)
src/misc/free_parse_tools.c:			free(list->name);
src/misc/free_parse_tools.c:		list = list->next;
src/misc/rt_error.c:	t->input->file_name, t->input->line_number, (char *)msg);
src/misc/rt_error.c:	t->input->file_name, t->input->line_number, (char *)msg);
src/objparser/objparser.c:	list->content = new_content;
src/objparser/objparser.c:	list->content_size = content_size;
src/objparser/objparser.c:	list->next = NULL;
src/objparser/objparser.c:			err = set_vec(l, &olist->vertex, &ind->i);
src/objparser/objparser.c:			err = set_vec(l, &olist->normal, &ind->j);
src/objparser/objparser.c:			err = set_triangle(l, &olist->triangle, ind);
src/parsing/get_file.c:		new_input->line_number = ++line;
src/parsing/get_file.c:		input_pushback(&t->input, new_input);
src/parsing/get_token.c:		if (t->tokens[i] == NULL)
src/parsing/get_token.c:		if (!ft_strcmp(t->tokens[i], key))
src/parsing/init_parse_tools.c:	t->in_scene = false;
src/parsing/init_parse_tools.c:	t->in_object = false;
src/parsing/init_parse_tools.c:	t->input = NULL;
src/parsing/init_parse_tools.c:	t->input_head = NULL;
src/parsing/init_parse_tools.c:	t->scene = NULL;
src/parsing/init_parse_tools.c:	t->current_object = NULL;
src/parsing/init_parse_tools.c:	t->current_camera = NULL;
src/parsing/init_parse_tools.c:	t->current_light = NULL;
src/parsing/init_parse_tools.c:	t->current_type = T_INVALID_TOKEN;
src/parsing/init_parse_tools.c:	t->fd = -1;
src/parsing/init_parse_tools.c:	t->file_name = NULL;
src/parsing/init_parse_tools.c:	t->colors = NULL;
src/parsing/init_parse_tools.c:	t->global_attributes = NULL;
src/parsing/init_parse_tools.c:	t->scene_attributes = NULL;
src/parsing/init_parse_tools.c:	t->object_attributes = NULL;
src/parsing/init_parse_tools.c:	if (!(t->global_attributes =
src/parsing/init_parse_tools.c:	if (!(t->scene_attributes =
src/parsing/init_parse_tools.c:	if (!(t->object_attributes =
src/parsing/init_parse_tools.c:	reset_attributes(t->global_attributes);
src/parsing/init_parse_tools.c:	reset_attributes(t->scene_attributes);
src/parsing/init_parse_tools.c:	reset_attributes(t->object_attributes);
src/parsing/init_parse_tools.c:	if (!(t->parse = malloc(sizeof(t->parse) * T_COUNT)))
src/parsing/init_parse_tools.c:	t->parse[T_CLOSE_BRACKET] = &parse_close_bracket;
src/parsing/init_parse_tools.c:	t->parse[T_OPEN_BRACKET] = &parse_open_bracket;
src/parsing/init_parse_tools.c:	t->parse[T_EMPTY_LINE] = &parse_empty_line;
src/parsing/init_parse_tools.c:	t->parse[T_SCENE] = &parse_scene;
src/parsing/init_parse_tools.c:	t->parse[T_CAMERA] = &parse_camera;
src/parsing/init_parse_tools.c:	t->parse[T_LIGHT] = &parse_light;
src/parsing/init_parse_tools.c:	t->parse[T_PLANE] = &parse_plane;
src/parsing/init_parse_tools.c:	t->parse[T_DISK] = &parse_disk;
src/parsing/init_parse_tools.c:	t->parse[T_SPHERE] = &parse_sphere;
src/parsing/init_parse_tools.c:	t->parse[T_CYLINDER] = &parse_cylinder;
src/parsing/init_parse_tools.c:	t->parse[T_CONE] = &parse_cone;
src/parsing/init_parse_tools.c:	t->parse[T_PARABOLOID] = &parse_paraboloid;
src/parsing/init_parse_tools.c:	t->parse[T_TRIANGLE] = NULL; //&parse_triangle;
src/parsing/init_parse_tools.c:	t->parse[T_TORUS] = &parse_torus;
src/parsing/init_parse_tools.c:	t->parse[T_OBJ] = &parse_obj;
src/parsing/init_parse_tools.c:	t->parse[T_RESOLUTION] = &parse_resolution;
src/parsing/init_parse_tools.c:	t->parse[T_RAY_DEPTH] = &parse_ray_depth;
src/parsing/init_parse_tools.c:	t->parse[T_BACKGROUND_COLOR] = &parse_background_color;
src/parsing/init_parse_tools.c:	t->parse[T_AMBIENT_LIGHT_COLOR] = &parse_ambient_light_color;
src/parsing/init_parse_tools.c:	t->parse[T_KA] = &parse_ka;
src/parsing/init_parse_tools.c:	t->parse[T_POSITION] = &parse_position;
src/parsing/init_parse_tools.c:	t->parse[T_DIRECTION] = &parse_direction;
src/parsing/init_parse_tools.c:	t->parse[T_LOOK_AT] = &parse_look_at;
src/parsing/init_parse_tools.c:	t->parse[T_COLOR] = &parse_color;
src/parsing/init_parse_tools.c:	t->parse[T_RADIUS] = &parse_radius;
src/parsing/init_parse_tools.c:	t->parse[T_HEIGHT] = &parse_height;
src/parsing/init_parse_tools.c:	t->parse[T_DIFFUSE_COEF] = &parse_diffuse_coef;
src/parsing/init_parse_tools.c:	t->parse[T_REFRACTION_INDEX] = &parse_ior;
src/parsing/init_parse_tools.c:	t->parse[T_REFLECTION] = &parse_reflection;
src/parsing/init_parse_tools.c:	t->parse[T_SPECULAR_EXPONENT] = &parse_specular_exponent;
src/parsing/init_parse_tools.c:	t->parse[T_SPECULAR_COEF] = &parse_specular_coef;
src/parsing/init_parse_tools.c:	t->parse[T_TRANSPARENCY] = &parse_transparency;
src/parsing/init_parse_tools.c:	t->parse[T_FOV] = &parse_fov;
src/parsing/init_parse_tools.c:	t->parse[T_INTENSITY] = &parse_intensity;
src/parsing/init_parse_tools.c:	t->parse[T_FILTER] = &parse_filter;
src/parsing/init_parse_tools.c:	t->parse[T_READ_NORMAL_MAP] = &read_normal_map;
src/parsing/init_parse_tools.c:	t->parse[T_READ_OBJ_FILE] = &read_obj_file;
src/parsing/init_parse_tools.c:	t->parse[T_READ_TEXTURE_FILE] = &read_texture_file;
src/parsing/init_parse_tools.c:	t->parse[T_READ_MATERIAL_FILE] = &read_material_file;
src/parsing/init_parse_tools.c:	t->parse[T_HASHTAG] = &hashtag;
src/parsing/init_parse_tools.c:	t->parse[T_INVALID_TOKEN] = &invalid_token;
src/parsing/init_tokens.c:	if (!(t->tokens = (char **)ft_memalloc(sizeof(char *) * T_COUNT + 1)))
src/parsing/init_tokens.c:	if ((!(t->tokens[T_OPEN_BRACKET] = ft_strdup("{"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_CLOSE_BRACKET] = ft_strdup("}"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_EMPTY_LINE] = ft_strdup(""))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_SCENE] = ft_strdup("scene"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_CAMERA] = ft_strdup("camera"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_LIGHT] = ft_strdup("light"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_PLANE] = ft_strdup("plane"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_DISK] = ft_strdup("disk"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_SPHERE] = ft_strdup("sphere"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_CYLINDER] = ft_strdup("cylinder"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_CONE] = ft_strdup("cone"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_PARABOLOID] = ft_strdup("paraboloid"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_TORUS] = ft_strdup("torus"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_TRIANGLE] = ft_strdup("triangle"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_OBJ] = ft_strdup("obj"))) ||		
src/parsing/init_tokens.c:		(!(t->tokens[T_RESOLUTION] = ft_strdup("resolution"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_RAY_DEPTH] = ft_strdup("ray depth"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_BACKGROUND_COLOR] = ft_strdup("background color"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_KA] = ft_strdup("ka"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_AMBIENT_LIGHT_COLOR] =
src/parsing/init_tokens.c:		(!(t->tokens[T_POSITION] = ft_strdup("position"))))
src/parsing/init_tokens.c:	if ((!(t->tokens[T_DIRECTION] = ft_strdup("direction"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_LOOK_AT] = ft_strdup("look at"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_COLOR] = ft_strdup("color"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_RADIUS] = ft_strdup("radius"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_HEIGHT] = ft_strdup("height"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_DIFFUSE_COEF] = ft_strdup("kd"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_REFRACTION_INDEX] = ft_strdup("ior"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_REFLECTION] = ft_strdup("reflection"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_SPECULAR_EXPONENT] = ft_strdup("specular exponent"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_SPECULAR_COEF] = ft_strdup("ks"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_TRANSPARENCY] = ft_strdup("transparency"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_FOV] = ft_strdup("fov"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_INTENSITY] = ft_strdup("intensity"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_FILTER] = ft_strdup("filter"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_READ_NORMAL_MAP] = ft_strdup("normal map"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_READ_TEXTURE_FILE] = ft_strdup("texture"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_READ_OBJ_FILE] = ft_strdup("source"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_READ_MATERIAL_FILE] =
src/parsing/init_tokens.c:		(!(t->tokens[T_HASHTAG] = ft_strdup("#"))) ||
src/parsing/init_tokens.c:		(!(t->tokens[T_INVALID_TOKEN] = ft_strdup("invalid token"))))
src/parsing/init_tokens.c:	t->tokens[T_COUNT] = NULL;
src/parsing/parse_color_name.c:	if (!t->colors)
src/parsing/parse_color_name.c:		init_color_list(&t->colors);
src/parsing/parse_color_name.c:	if (find_color_value(t->colors, value, &new_col))
src/parsing/parse_input.c:	t->input_head = t->input;
src/parsing/parse_input.c:	while (t->input)
src/parsing/parse_input.c:		if ((ret = t->parse[t->input->token](t)))
src/parsing/parse_input.c:		t->input = t->input->next;
src/parsing/parse_input.c:	if (t->in_scene || t->in_object)
src/parsing/parse_value_1.c:	if (t->in_object)
src/parsing/parse_value_1.c:		set_attributes(t, t->object_attributes);
src/parsing/parse_value_1.c:		reset_attributes(t->object_attributes);
src/parsing/parse_value_1.c:		t->in_object = false;
src/parsing/parse_value_1.c:	else if (t->in_scene)
src/parsing/parse_value_1.c:		t->in_scene = false;
src/parsing/parse_value_1.c:	t->scene = get_new_scene(t);
src/parsing/parse_value_1.c:	if (t->global_attributes->res.x != -1)
src/parsing/parse_value_1.c:		t->scene->res = t->global_attributes->res;
src/parsing/parse_value_1.c:	if (t->global_attributes->ray_depth != -1)
src/parsing/parse_value_1.c:		t->scene->ray_depth = t->global_attributes->ray_depth;
src/parsing/parse_value_1.c:	if (!isnan(t->global_attributes->ka))
src/parsing/parse_value_1.c:		t->scene->ka = t->global_attributes->ka;
src/parsing/parse_value_1.c:	if (!v_isnan(t->global_attributes->ambient_light_color))
src/parsing/parse_value_1.c:		t->scene->ambient_light_color =
src/parsing/parse_value_1.c:			t->global_attributes->ambient_light_color;
src/parsing/parse_value_1.c:	t->input = t->input->next;
src/parsing/parse_value_1.c:	t->current_type = T_CAMERA;
src/parsing/parse_value_1.c:	t->current_camera = get_new_camera(t);
src/parsing/parse_value_1.c:	push_camera(&t->scene->cameras, t->current_camera);
src/parsing/parse_value_1.c:	set_attributes(t, t->global_attributes);
src/parsing/parse_value_1.c:	set_attributes(t, t->scene_attributes);
src/parsing/parse_value_1.c:	t->input = t->input->next;
src/parsing/parse_value_10.c:	t->current_object = get_new_object(t);
src/parsing/parse_value_10.c:	t->current_type = T_TORUS;
src/parsing/parse_value_10.c:	t->current_object->rad_torus = 0.1;
src/parsing/parse_value_10.c:	push_object(&t->scene->objects, t->current_object);
src/parsing/parse_value_10.c:	set_attributes(t, t->global_attributes);
src/parsing/parse_value_10.c:	set_attributes(t, t->scene_attributes);
src/parsing/parse_value_10.c:	t->input = t->input->next;
src/parsing/parse_value_10.c:	t->current_object = get_new_object(t);
src/parsing/parse_value_10.c:	t->current_type = T_PARABOLOID;
src/parsing/parse_value_10.c:	push_object(&t->scene->objects, t->current_object);
src/parsing/parse_value_10.c:	set_attributes(t, t->global_attributes);
src/parsing/parse_value_10.c:	set_attributes(t, t->scene_attributes);
src/parsing/parse_value_10.c:	t->input = t->input->next;
src/parsing/parse_value_2.c:	t->current_type = T_LIGHT;
src/parsing/parse_value_2.c:	t->current_light = get_new_light(t);
src/parsing/parse_value_2.c:	push_light(&t->scene->lights, t->current_light);
src/parsing/parse_value_2.c:	set_attributes(t, t->global_attributes);
src/parsing/parse_value_2.c:	set_attributes(t, t->scene_attributes);
src/parsing/parse_value_2.c:	t->input = t->input->next;
src/parsing/parse_value_2.c:	t->current_type = T_PLANE;
src/parsing/parse_value_2.c:	t->current_object = get_new_object(t);
src/parsing/parse_value_2.c:	push_object(&t->scene->objects, t->current_object);
src/parsing/parse_value_2.c:	set_attributes(t, t->global_attributes);
src/parsing/parse_value_2.c:	set_attributes(t, t->scene_attributes);
src/parsing/parse_value_2.c:	t->input = t->input->next;
src/parsing/parse_value_2.c:	t->current_type = T_DISK;
src/parsing/parse_value_2.c:	t->current_object = get_new_object(t);
src/parsing/parse_value_2.c:	push_object(&t->scene->objects, t->current_object);
src/parsing/parse_value_2.c:	set_attributes(t, t->global_attributes);
src/parsing/parse_value_2.c:	set_attributes(t, t->scene_attributes);
src/parsing/parse_value_2.c:	t->input = t->input->next;
src/parsing/parse_value_2.c:	t->current_object = get_new_object(t);
src/parsing/parse_value_2.c:	t->current_type = T_SPHERE;
src/parsing/parse_value_2.c:	push_object(&t->scene->objects, t->current_object);
src/parsing/parse_value_2.c:	set_attributes(t, t->global_attributes);
src/parsing/parse_value_2.c:	set_attributes(t, t->scene_attributes);
src/parsing/parse_value_2.c:	t->input = t->input->next;
src/parsing/parse_value_2.c:	t->current_object = get_new_object(t);
src/parsing/parse_value_2.c:	t->current_type = T_CYLINDER;
src/parsing/parse_value_2.c:	push_object(&t->scene->objects, t->current_object);
src/parsing/parse_value_2.c:	set_attributes(t, t->global_attributes);
src/parsing/parse_value_2.c:	set_attributes(t, t->scene_attributes);
src/parsing/parse_value_2.c:	t->input = t->input->next;
src/parsing/parse_value_3.c:	t->current_object = get_new_object(t);
src/parsing/parse_value_3.c:	t->current_type = T_CONE;
src/parsing/parse_value_3.c:	push_object(&t->scene->objects, t->current_object);
src/parsing/parse_value_3.c:	set_attributes(t, t->global_attributes);
src/parsing/parse_value_3.c:	set_attributes(t, t->scene_attributes);
src/parsing/parse_value_3.c:	t->input = t->input->next;
src/parsing/parse_value_3.c:	if (ft_charcount(t->input->value, ',') != 1 && (invalid = true))
src/parsing/parse_value_3.c:	s2 = split_trim(t->input->value, ',');
src/parsing/parse_value_3.c:	if (!t->in_scene)
src/parsing/parse_value_3.c:		t->global_attributes->res = new_res;
src/parsing/parse_value_3.c:	else if (!t->in_object)
src/parsing/parse_value_3.c:		t->scene->res = new_res;
src/parsing/parse_value_3.c:	else if (t->in_object)
src/parsing/parse_value_3.c:	if (!t->input->value)
src/parsing/parse_value_3.c:	if ((new_ray_depth = ft_atoi(t->input->value)) < 1)
src/parsing/parse_value_3.c:	if (!t->in_scene)
src/parsing/parse_value_3.c:		t->global_attributes->ray_depth = new_ray_depth;
src/parsing/parse_value_3.c:	else if (!t->in_object)
src/parsing/parse_value_3.c:		t->scene->ray_depth = new_ray_depth;
src/parsing/parse_value_3.c:	else if (t->in_object)
src/parsing/parse_value_3.c:	if (v_isnan(new_col = get_color(t, t->input->value)))
src/parsing/parse_value_3.c:	if (!t->in_scene)
src/parsing/parse_value_3.c:		t->global_attributes->col = new_col;
src/parsing/parse_value_3.c:	else if (!t->in_object)
src/parsing/parse_value_3.c:		t->scene->background_color = new_col;
src/parsing/parse_value_3.c:	else if (t->in_object)
src/parsing/parse_value_4.c:	if (v_isnan(new_col = get_color(t, t->input->value)))
src/parsing/parse_value_4.c:	if (!t->in_scene)
src/parsing/parse_value_4.c:		t->global_attributes->ambient_light_color = new_col;
src/parsing/parse_value_4.c:	else if (!t->in_object)
src/parsing/parse_value_4.c:		t->scene->ambient_light_color = new_col;
src/parsing/parse_value_4.c:	else if (t->in_object)
src/parsing/parse_value_4.c:	if (isnan(new_intensity = parse_float(t->input->value)) ||
src/parsing/parse_value_4.c:	if (!t->in_scene)
src/parsing/parse_value_4.c:		t->global_attributes->ka = new_intensity;
src/parsing/parse_value_4.c:	else if (!t->in_object)
src/parsing/parse_value_4.c:		t->scene->ka = new_intensity;
src/parsing/parse_value_4.c:	else if (t->in_object)
src/parsing/parse_value_4.c:	if (v_isnan(new_pos = parse_vector(t->input->value)))
src/parsing/parse_value_4.c:	if (!t->in_scene)
src/parsing/parse_value_4.c:		t->global_attributes->pos = new_pos;
src/parsing/parse_value_4.c:	else if (!t->in_object)
src/parsing/parse_value_4.c:		t->scene_attributes->pos = new_pos;
src/parsing/parse_value_4.c:	else if (t->in_object)
src/parsing/parse_value_4.c:		t->object_attributes->pos = new_pos;
src/parsing/parse_value_4.c:	if (v_isnan(new_dir = parse_vector(t->input->value)))
src/parsing/parse_value_4.c:	if (!t->in_scene)
src/parsing/parse_value_4.c:		t->global_attributes->dir = new_dir;
src/parsing/parse_value_4.c:	else if (!t->in_object)
src/parsing/parse_value_4.c:		t->scene_attributes->dir = new_dir;
src/parsing/parse_value_4.c:	else if (t->in_object)
src/parsing/parse_value_4.c:		t->object_attributes->dir = new_dir;
src/parsing/parse_value_5.c:	if (v_isnan(new_look_at = parse_vector(t->input->value))
src/parsing/parse_value_5.c:		&& v_isnan(new_look_at = look_at_object(t, t->input->value)))
src/parsing/parse_value_5.c:	if (!t->in_scene)
src/parsing/parse_value_5.c:		t->global_attributes->look_at = new_look_at;
src/parsing/parse_value_5.c:	else if (!t->in_object)
src/parsing/parse_value_5.c:		t->scene_attributes->look_at = new_look_at;
src/parsing/parse_value_5.c:	else if (t->in_object)
src/parsing/parse_value_5.c:		t->object_attributes->look_at = new_look_at;
src/parsing/parse_value_5.c:	if (v_isnan(new_col = get_color(t, t->input->value)))
src/parsing/parse_value_5.c:	if (!t->in_scene)
src/parsing/parse_value_5.c:		t->global_attributes->col = new_col;
src/parsing/parse_value_5.c:	else if (!t->in_object)
src/parsing/parse_value_5.c:		t->scene_attributes->col = new_col;
src/parsing/parse_value_5.c:	else if (t->in_object)
src/parsing/parse_value_5.c:		t->object_attributes->col = new_col;
src/parsing/parse_value_5.c:	if (isnan(new_radius = parse_float(t->input->value)) ||
src/parsing/parse_value_5.c:	if (!t->in_scene)
src/parsing/parse_value_5.c:		t->global_attributes->rad = new_radius;
src/parsing/parse_value_5.c:	else if (!t->in_object)
src/parsing/parse_value_5.c:		t->scene_attributes->rad = new_radius;
src/parsing/parse_value_5.c:	else if (t->in_object)
src/parsing/parse_value_5.c:		t->object_attributes->rad = new_radius;
src/parsing/parse_value_5.c:	if (t->in_object && t->current_type != T_CONE &&
src/parsing/parse_value_5.c:		t->current_type != T_CYLINDER &&
src/parsing/parse_value_5.c:	t->current_type != T_SPHERE && t->current_type != T_OBJ
src/parsing/parse_value_5.c:		&& t->current_type != T_DISK && t->current_type != T_TORUS && t->current_type != T_PARABOLOID)
src/parsing/parse_value_5.c:	if (isnan(new_height = parse_float(t->input->value)) ||
src/parsing/parse_value_5.c:	if (!t->in_scene)
src/parsing/parse_value_5.c:		t->global_attributes->height = new_height;
src/parsing/parse_value_5.c:	else if (!t->in_object)
src/parsing/parse_value_5.c:		t->scene_attributes->height = new_height;
src/parsing/parse_value_5.c:	else if (t->in_object)
src/parsing/parse_value_5.c:		t->object_attributes->height = new_height;
src/parsing/parse_value_5.c:	if (t->in_object && t->current_type != T_CONE &&
src/parsing/parse_value_5.c:		t->current_type != T_CYLINDER && t->current_type != T_OBJ && t->current_type != T_PARABOLOID)
src/parsing/parse_value_5.c:	if (isnan(new_diffuse_coef = parse_float(t->input->value)) ||
src/parsing/parse_value_5.c:	if (!t->in_scene)
src/parsing/parse_value_5.c:		t->global_attributes->kd = new_diffuse_coef;
src/parsing/parse_value_5.c:	else if (!t->in_object)
src/parsing/parse_value_5.c:		t->scene_attributes->kd = new_diffuse_coef;
src/parsing/parse_value_5.c:	else if (t->in_object)
src/parsing/parse_value_5.c:		t->object_attributes->kd = new_diffuse_coef;
src/parsing/parse_value_5.c:	if (t->in_object && (t->current_type == T_LIGHT ||
src/parsing/parse_value_5.c:		t->current_type == T_CAMERA))
src/parsing/parse_value_6.c:	if (isnan(new_specular_coef = parse_float(t->input->value)) ||
src/parsing/parse_value_6.c:	if (!t->in_scene)
src/parsing/parse_value_6.c:		t->global_attributes->ks = new_specular_coef;
src/parsing/parse_value_6.c:	else if (!t->in_object)
src/parsing/parse_value_6.c:		t->scene_attributes->ks = new_specular_coef;
src/parsing/parse_value_6.c:	else if (t->in_object)
src/parsing/parse_value_6.c:		t->object_attributes->ks = new_specular_coef;
src/parsing/parse_value_6.c:	if (t->in_object && (t->current_type == T_LIGHT ||
src/parsing/parse_value_6.c:		t->current_type == T_CAMERA))
src/parsing/parse_value_6.c:	if (isnan(new_specular_exp = parse_float(t->input->value)) ||
src/parsing/parse_value_6.c:	if (!t->in_scene)
src/parsing/parse_value_6.c:		t->global_attributes->specular_exp = new_specular_exp;
src/parsing/parse_value_6.c:	else if (!t->in_object)
src/parsing/parse_value_6.c:		t->scene_attributes->specular_exp = new_specular_exp;
src/parsing/parse_value_6.c:	else if (t->in_object)
src/parsing/parse_value_6.c:		t->object_attributes->specular_exp = new_specular_exp;
src/parsing/parse_value_6.c:	if (t->in_object && (t->current_type == T_LIGHT ||
src/parsing/parse_value_6.c:		t->current_type == T_CAMERA))
src/parsing/parse_value_6.c:	if (isnan(new_ior = parse_float(t->input->value)) || new_ior < 1)
src/parsing/parse_value_6.c:	if (!t->in_scene)
src/parsing/parse_value_6.c:		t->global_attributes->ior = new_ior;
src/parsing/parse_value_6.c:	else if (!t->in_object)
src/parsing/parse_value_6.c:		t->scene_attributes->ior = new_ior;
src/parsing/parse_value_6.c:	else if (t->in_object)
src/parsing/parse_value_6.c:		t->object_attributes->ior = new_ior;
src/parsing/parse_value_6.c:	// else if (t->current_type == T_CAMERA)
src/parsing/parse_value_6.c:	// 	t->current_camera->ior = new_ior;
src/parsing/parse_value_6.c:	if (t->in_object && t->current_type == T_LIGHT)
src/parsing/parse_value_6.c:	if (isnan(new_reflection_coef = parse_float(t->input->value)) ||
src/parsing/parse_value_6.c:	if (!t->in_scene)
src/parsing/parse_value_6.c:		t->global_attributes->reflection = new_reflection_coef;
src/parsing/parse_value_6.c:	else if (!t->in_object)
src/parsing/parse_value_6.c:		t->scene_attributes->reflection = new_reflection_coef;
src/parsing/parse_value_6.c:	else if (t->in_object)
src/parsing/parse_value_6.c:		t->object_attributes->reflection = new_reflection_coef;
src/parsing/parse_value_6.c:	if (t->in_object && (t->current_type == T_LIGHT ||
src/parsing/parse_value_6.c:		t->current_type == T_CAMERA))
src/parsing/parse_value_6.c:	if (isnan(new_transparency_coef = parse_float(t->input->value)) ||
src/parsing/parse_value_6.c:	if (!t->in_scene)
src/parsing/parse_value_6.c:		t->global_attributes->transparency = new_transparency_coef;
src/parsing/parse_value_6.c:	else if (!t->in_object)
src/parsing/parse_value_6.c:		t->scene_attributes->transparency = new_transparency_coef;
src/parsing/parse_value_6.c:	else if (t->in_object)
src/parsing/parse_value_6.c:		t->object_attributes->transparency = new_transparency_coef;
src/parsing/parse_value_6.c:	if (t->in_object && (t->current_type == T_LIGHT ||
src/parsing/parse_value_6.c:		t->current_type == T_CAMERA))
src/parsing/parse_value_7.c:	if (isnan(new_fov = parse_float(t->input->value)) ||
src/parsing/parse_value_7.c:	if (!t->in_scene)
src/parsing/parse_value_7.c:		t->global_attributes->fov = new_fov;
src/parsing/parse_value_7.c:	else if (!t->in_object)
src/parsing/parse_value_7.c:		t->scene_attributes->fov = new_fov;
src/parsing/parse_value_7.c:	else if (t->in_object)
src/parsing/parse_value_7.c:		t->object_attributes->fov = new_fov;
src/parsing/parse_value_7.c:	if (t->in_object && t->current_type != T_CAMERA)
src/parsing/parse_value_7.c:	if (isnan(new_intensity = parse_float(t->input->value)) ||
src/parsing/parse_value_7.c:	if (!t->in_scene)
src/parsing/parse_value_7.c:		t->global_attributes->intensity = new_intensity;
src/parsing/parse_value_7.c:	else if (!t->in_object)
src/parsing/parse_value_7.c:		t->scene_attributes->intensity = new_intensity;
src/parsing/parse_value_7.c:	else if (t->in_object)
src/parsing/parse_value_7.c:		t->object_attributes->intensity = new_intensity;
src/parsing/parse_value_7.c:	if (t->in_object && t->current_type != T_LIGHT)
src/parsing/parse_value_7.c:	ft_strtoupper(t->input->value);
src/parsing/parse_value_7.c:	if (ft_strcmp(t->input->value, "BLACK AND WHITE") == 0)
src/parsing/parse_value_7.c:		t->current_camera->filter = F_BW;
src/parsing/parse_value_7.c:	else if (ft_strcmp(t->input->value, "SEPIA") == 0)
src/parsing/parse_value_7.c:		t->current_camera->filter = F_SEPIA;
src/parsing/parse_value_7.c:	else if (ft_strcmp(t->input->value, "DEUTAN") == 0)
src/parsing/parse_value_7.c:		t->current_camera->filter = F_DEUTAN;
src/parsing/parse_value_7.c:	if (!t->input->value)
src/parsing/parse_value_7.c:	if (!check_file_ext(t->input->value, "BMP"))
src/parsing/parse_value_7.c:	if (!(normal_map = read_bmp(t->input->value, &t->current_object->normal_map_dim)))
src/parsing/parse_value_7.c:	t->current_object->normal_map_name = ft_strdup(t->input->value); // free?
src/parsing/parse_value_7.c:	t->current_object->normal_map = normal_map;
src/parsing/parse_value_7.c:	if ((ret = objparser(t->input->value, &new_obj)))
src/parsing/parse_value_7.c:	if (!t->in_scene)
src/parsing/parse_value_7.c:		t->global_attributes->obj = new_obj;
src/parsing/parse_value_7.c:	else if (!t->in_object)
src/parsing/parse_value_7.c:		t->scene_attributes->obj = new_obj;
src/parsing/parse_value_7.c:	else if (t->in_object)
src/parsing/parse_value_7.c:		t->object_attributes->obj = new_obj;
src/parsing/parse_value_7.c:	t->object_attributes->rad = v_dist(new_obj->far_point1, (t_vec3){0, 0, 0}) * 2;
src/parsing/parse_value_7.c:	t->current_object = get_new_object(t);
src/parsing/parse_value_7.c:	t->current_type = T_OBJ;
src/parsing/parse_value_7.c:	push_object(&t->scene->objects, t->current_object);
src/parsing/parse_value_7.c:	set_attributes(t, t->global_attributes);
src/parsing/parse_value_7.c:	set_attributes(t, t->scene_attributes);
src/parsing/parse_value_7.c:	t->input = t->input->next;
src/parsing/parse_value_8.c:	if (!t->input->value)
src/parsing/parse_value_8.c:	res = ft_strsplit(t->input->value, ' ');
src/parsing/parse_value_8.c:		if (v_isnan(resolution = parse_vector(t->input->value + ft_strlen(res[0]))))
src/parsing/parse_value_8.c:		t->current_object->texture_name = ft_strdup("Perlin");
src/parsing/parse_value_8.c:		t->current_object->texture = generate_perlin_noise(&resolution);
src/parsing/parse_value_8.c:		t->current_object->texture_dim = resolution;
src/parsing/parse_value_8.c:		if (v_isnan(resolution = parse_vector(t->input->value + ft_strlen(res[0]))))
src/parsing/parse_value_8.c:		t->current_object->texture_name = ft_strdup("Checkerboard");
src/parsing/parse_value_8.c:		t->current_object->texture = generate_checkerboard(&resolution);
src/parsing/parse_value_8.c:		t->current_object->texture_dim = resolution;
src/parsing/parse_value_8.c:		if (v_isnan(resolution = parse_vector(t->input->value + ft_strlen(res[0]))))
src/parsing/parse_value_8.c:		t->current_object->texture_name = ft_strdup("Noise");
src/parsing/parse_value_8.c:		t->current_object->texture = generate_noise(&resolution);
src/parsing/parse_value_8.c:		t->current_object->texture_dim = resolution;
src/parsing/parse_value_8.c:		if (!check_file_ext(t->input->value, "BMP"))
src/parsing/parse_value_8.c:		printf("%s\n", t->input->value);
src/parsing/parse_value_8.c:		if (!(texture = read_bmp(t->input->value, &t->current_object->texture_dim)))
src/parsing/parse_value_8.c:		t->current_object->texture_name = ft_strdup(t->input->value); // free?
src/parsing/parse_value_8.c:		t->current_object->texture = texture;
src/parsing/parse_value_9.c:	if (!t->in_scene)
src/parsing/parse_value_9.c:		t->in_scene = true;
src/parsing/parse_value_9.c:	if (t->scene)
src/parsing/parse_value_9.c:	if (!t->input->next)
src/parsing/parse_value_9.c:	if (t->input->next->token != T_OPEN_BRACKET)
src/parsing/parse_value_9.c:		t->input = t->input->next;
src/parsing/parse_value_9.c:	if (!t->in_scene)
src/parsing/parse_value_9.c:	if (!t->in_object)
src/parsing/parse_value_9.c:		t->in_object = true;
src/parsing/parse_value_9.c:	if (t->input->next->token != T_OPEN_BRACKET)
src/parsing/parse_value_9.c:		t->input = t->input->next;
src/parsing/parse_value_9.c:	o_ptr = t->scene->objects;
src/parsing/parse_value_9.c:	l_ptr = t->scene->lights;
src/parsing/parse_value_9.c:	c_ptr = t->scene->cameras;
src/parsing/reset_attributes.c:	att->res.x = -1;
src/parsing/reset_attributes.c:	att->res.y = -1;
src/parsing/reset_attributes.c:	att->ray_depth = -1;
src/parsing/reset_attributes.c:	att->ka = NAN;
src/parsing/reset_attributes.c:	att->ambient_light_color = v_new(NAN, NAN, NAN);
src/parsing/reset_attributes.c:	att->intensity = NAN;
src/parsing/reset_attributes.c:	att->fov = NAN;
src/parsing/reset_attributes.c:	att->pos = v_new(NAN, NAN, NAN);
src/parsing/reset_attributes.c:	att->dir = v_new(NAN, NAN, NAN);
src/parsing/reset_attributes.c:	att->look_at = v_new(NAN, NAN, NAN);
src/parsing/reset_attributes.c:	att->col = v_new(NAN, NAN, NAN);
src/parsing/reset_attributes.c:	att->rad = NAN;
src/parsing/reset_attributes.c:	att->height = NAN;
src/parsing/reset_attributes.c:	att->ior = NAN;
src/parsing/reset_attributes.c:	att->reflection = NAN;
src/parsing/reset_attributes.c:	att->specular_exp = NAN;
src/parsing/reset_attributes.c:	att->kd = NAN;
src/parsing/reset_attributes.c:	att->ks = NAN;
src/parsing/reset_attributes.c:	att->transparency = NAN;
src/parsing/reset_attributes.c:	att->obj = NULL;
src/parsing/set_attributes_1.c:	t->current_type == T_CAMERA ? set_attributes_camera(t, a) : 0;
src/parsing/set_attributes_1.c:	t->current_type == T_LIGHT ? set_attributes_light(t, a) : 0;
src/parsing/set_attributes_1.c:	if (t->current_type == T_CAMERA || t->current_type == T_LIGHT)
src/parsing/set_attributes_1.c:		t->current_object->pos = a->pos;
src/parsing/set_attributes_1.c:		t->current_object->dir = a->dir;
src/parsing/set_attributes_1.c:		t->current_object->col = a->col;
src/parsing/set_attributes_1.c:	!isnan(a->ior) ? t->current_object->ior = a->ior : 0;
src/parsing/set_attributes_1.c:	!isnan(a->reflection) ? t->current_object->reflection = a->reflection : 0;
src/parsing/set_attributes_1.c:		t->current_object->specular_exp = a->specular_exp;
src/parsing/set_attributes_1.c:	!isnan(a->ks) ? t->current_object->ks = a->ks : 0;
src/parsing/set_attributes_1.c:	!isnan(a->kd) ? t->current_object->kd = a->kd : 0;
src/parsing/set_attributes_1.c:		t->current_object->transparency = a->transparency;
src/parsing/set_attributes_1.c:	if (t->current_type == T_PLANE || t->current_type == T_DISK)
src/parsing/set_attributes_1.c:	t->current_type == T_OBJ ? set_attributes_obj(t, a) : 0;
src/parsing/set_attributes_1.c:	t->current_type == T_SPHERE ? set_attributes_sphere(t, a) : 0;
src/parsing/set_attributes_1.c:	t->current_type == T_CYLINDER ? set_attributes_cylinder(t, a) : 0;
src/parsing/set_attributes_1.c:	t->current_type == T_CONE ? set_attributes_cone(t, a) : 0;
src/parsing/set_attributes_1.c:	t->current_type == T_PARABOLOID ? set_attributes_paraboloid(t, a) : 0;
src/parsing/set_attributes_1.c:	t->current_type == T_TORUS ? set_attributes_torus(t, a) : 0;
src/parsing/set_attributes_1.c:		t->current_camera->pos = a->pos;
src/parsing/set_attributes_1.c:		t->current_camera->fov = a->fov;
src/parsing/set_attributes_1.c:		t->current_camera->dir = a->dir;
src/parsing/set_attributes_1.c:		t->current_camera->look_at = a->look_at;
src/parsing/set_attributes_1.c:		t->current_camera->filter = a->filter;
src/parsing/set_attributes_1.c:		t->current_camera->ior = a->ior;
src/parsing/set_attributes_1.c:		t->current_light->pos = a->pos;
src/parsing/set_attributes_1.c:		t->current_light->dir = a->dir;
src/parsing/set_attributes_1.c:		t->current_light->look_at = a->look_at;
src/parsing/set_attributes_1.c:		t->current_light->col = a->col;
src/parsing/set_attributes_1.c:		t->current_light->intensity = a->intensity;
src/parsing/set_attributes_2.c:		t->current_object->look_at = a->look_at;
src/parsing/set_attributes_2.c:		t->current_object->rad = a->rad;
src/parsing/set_attributes_2.c:		t->current_object->rad = a->rad;
src/parsing/set_attributes_2.c:		t->current_object->look_at = a->look_at;
src/parsing/set_attributes_2.c:		t->current_object->rad = a->rad;
src/parsing/set_attributes_2.c:		t->current_object->height = a->height;
src/parsing/set_attributes_2.c:		t->current_object->look_at = a->look_at;
src/parsing/set_attributes_2.c:		t->current_object->rad = a->rad;
src/parsing/set_attributes_2.c:		t->current_object->height = a->height;
src/parsing/set_attributes_2.c:		t->current_object->look_at = a->look_at;
src/parsing/set_attributes_2.c:		t->current_object->rad = a->rad;
src/parsing/set_attributes_2.c:		t->current_object->height = a->height;
src/parsing/set_attributes_2.c:		t->current_object->rad_torus = a->rad_torus; // TODO
src/parsing/set_attributes_2.c:		t->current_object->look_at = a->look_at;
src/parsing/set_attributes_2.c:		t->current_object->rad = a->rad;
src/parsing/set_attributes_2.c:		t->current_object->height = a->height;
src/parsing/set_attributes_2.c:		t->current_object->obj = a->obj;
src/texture/export_bmp.c:	if (!(fd = open(th_export->filename, O_WRONLY | O_CREAT | O_TRUNC, 0600)))
src/texture/export_bmp.c:	write_header(fd, th_export->g->r->scene->res.x, th_export->g->r->scene->res.y);
src/texture/export_bmp.c:	while (++i < th_export->g->r->scene->res.x * th_export->g->r->scene->res.y)
src/texture/export_bmp.c:		r = th_export->g->r->d_pixel_map[i].r;
src/texture/export_bmp.c:		g = th_export->g->r->d_pixel_map[i].g;
src/texture/export_bmp.c:		b = th_export->g->r->d_pixel_map[i].b;
src/texture/export_bmp.c:		if (i % th_export->g->r->scene->res.x == 0)
src/texture/export_bmp.c:			th_export->progress = (double)i / (th_export->g->r->scene->res.x * th_export->g->r->scene->res.y) + 0.1;
